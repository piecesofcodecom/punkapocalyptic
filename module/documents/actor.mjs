/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class PunkapocalypticActor extends Actor {
    /** @override */
    prepareData() {
        // Prepare data for the actor. Calling the super version of this executes
        // the following, in order: data reset (to clear active effects),
        // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
        // prepareDerivedData().
        super.prepareData();
    }

    /** @override */
    prepareBaseData() {
        // Data modifications in this step occur before processing embedded
        // documents or derived data.
    }

    /**
     * @override
     * Augment the actor source data with additional dynamic data that isn't 
     * handled by the actor's DataModel. Data calculated in this step should be
     * available both inside and outside of character sheets (such as if an actor
     * is queried and has a roll executed directly from it).
     */
    prepareDerivedData() {
        const actorData = this;
        if (actorData.type == 'npc') return;
        const flags = actorData.flags.punkapocalyptic || {};
        const item_defense = actorData.items.filter(i => i.type == "armor" && i.system.equipped);
        console.warn(item_defense)
        if (item_defense.length) {
            if (item_defense[0].system.isBonus) {
                actorData.system.defense.current = actorData.system.defense.base + item_defense[0].system.defense;
            } else {
                actorData.system.defense.current = item_defense[0].system.defense;
            }
        } else {
            actorData.system.defense.current = actorData.system.defense.base;
        }
    }

    /**
     * 
     * @override
     * Augment the actor's default getRollData() method by appending the data object
     * generated by the its DataModel's getRollData(), or null. This polymorphic 
     * approach is useful when you have actors & items that share a parent Document, 
     * but have slightly different data preparation needs.
     */
    getRollData() {
        return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
    }

    /**
     * Convert the actor document to a plain object.
     * 
     * The built in `toObject()` method will ignore derived data when using Data Models.
     * This additional method will instead use the spread operator to return a simplified
     * version of the data.
     * 
     * @returns {object} Plain object either via deepClone or the spread operator.
     */
    toPlainObject() {
        const result = { ...this };

        // Simplify system data.
        result.system = this.system.toPlainObject();

        // Add items.
        result.items = this.items?.size > 0 ? this.items.contents : [];

        // Add effects.
        result.effects = this.effects?.size > 0 ? this.effects.contents : [];

        return result;
    }

    // async rollAbility(id, extraMod = 0) {

    //   const actor = this;
    //   if (actor.system.abilities.hasOwnProperty(id)) {
    //     const label = game.i18n.localize(CONFIG.PUNKAPOCALYPTIC.abilities[id]);
    //     const flavor = `<img src="${CONFIG.PUNKAPOCALYPTIC.abilityImages[id]}" alt="Icon" class="message-icon">
    //     <p style="font-family: 'Poison Hope', sans-serif;">Rolando ${label}</p>`;
    //       let roll = new Roll(`1d20+@abilities.${id}.mod+${extraMod}`, this.getRollData());
    //       console.warn("ROLL DATA",this.getRollData())
    //       roll.toMessage({
    //         speaker: ChatMessage.getSpeaker({ actor: actor }),
    //         flavor: flavor,
    //         rollMode: game.settings.get('core', 'rollMode'),
    //       });
    //       return roll;
    //     }

    // }

    async rollAbility(id, extraMod = 0, content = "") {
        const actor = this;
        if (!actor.system.abilities.hasOwnProperty(id)) return;

        const label = game.i18n.localize(CONFIG.PUNKAPOCALYPTIC.abilities[id]);
        const flavor = `
        <img src="${CONFIG.PUNKAPOCALYPTIC.abilityImages[id]}" alt="Icon" class="message-icon">
        <p style="font-family: 'Poison Hope', sans-serif; text-shadow: 2px 2px 5px gray;">Rolando ${label}</p>`;

        // Roll the base ability check: 1d20 + ability modifier
        let baseRoll = await new Roll(`1d20+@abilities.${id}.mod`, actor.getRollData()).evaluate({ evaluateSync: true });

        // Check if we need to roll extra d6 dice
        let extraDice = Math.abs(extraMod);
        let extraRoll = null;
        let highestD6 = 0;
        let extraType = ""; // Will hold "Complica√ß√µes" or "Recursos"
        let highlighDie = "";
        if (extraDice > 0) {
            extraRoll = await new Roll(`${extraDice}d6`).evaluate({ async: true });

            // Get the highest result from the rolled d6 dice
            highestD6 = Math.max(...extraRoll.dice[0].results.map(r => r.result));

            // Define whether it's a "Complica√ß√£o" or "Recurso"
            if (extraMod < 0) {
                highestD6 = -highestD6;
                extraType = "üî• <strong>Complica√ß√µes</strong>:";
                highlighDie = "min";
            } else {
                extraType = "üõ†Ô∏è <strong>Recursos</strong>:";
                highlighDie = "max";
            }
        }

        // Calculate final total
        let finalTotal = baseRoll.total + highestD6;

        // Construct chat message content

        // let messageContent = `
        //     üé≤ <strong>Base Roll:</strong> ${baseRoll.total} (1d20 + ${actor.system.abilities[id].mod})<br>
        //     ${extraRoll ? `${extraType} ${extraRoll.dice[0].results.map(r => r.result).join(", ")} ‚Üí <span style="color: ${extraMod < 0 ? 'red' : 'green'};">${highestD6}</span>` : ""}
        //     <hr>
        //     <strong>Final Total:</strong> <span style="font-size: 1.2em; color: green;">${finalTotal}</span>
        // `;

        let modifier = "";
        if (Number(actor.system.abilities[id].mod) != 0) {
            const value = Math.abs(actor.system.abilities[id].mod);
            modifier = Math.sign(actor.system.abilities[id].mod) > 0 ? " + " + value : " - " + value;
        }

        let baseDiceHTML = `
        <div class="dice">
            <header class="part-header flexrow">
                <span class="part-formula">1d20${modifier}</span>
                <span class="part-total">${baseRoll.total}</span>
            </header>
            <ol class="dice-rolls">
                <li class="roll die d20 max">${baseRoll.terms[0].results[0].result}</li>
            </ol>
        </div>`;

        let extraDiceHTML = extraRoll ? `
        <div class="dice">
            <header class="part-header flexrow">
                <span class="part-formula">${extraDice}d6</span>
                <span class="part-total">${highestD6}</span>
            </header>
            <ol class="dice-rolls">
                ${extraRoll.dice[0].results.map(r => r.result == Math.abs(highestD6) ? (`<li class="roll die d6 ${highlighDie}">${r.result}</li>`) : (`<li class="roll die d6">${r.result}</li>`)).join("")}
            </ol>
        </div>` : "";

        let messageContent = `
        <div class="dice-roll">
            <div class="dice-result">
                <div class="dice-formula">1d20${modifier}</div>
                <div class="dice-tooltip">
                    <section class="tooltip-part">${baseDiceHTML}</section>
                </div>

                ${extraRoll ? `
                <div class="dice-formula">${extraDice}d6</div>
                <div class="dice-tooltip">
                    <section class="tooltip-part">${extraDiceHTML}</section>
                </div>` : ""}

                <h4 class="dice-total">${finalTotal}</h4>
            </div>
        </div>`;



        // Send message to chat
        ChatMessage.create({
            speaker: ChatMessage.getSpeaker({ actor: actor }),
            flavor: content.length > 0 ? content : flavor,
            content: messageContent,
            rollMode: game.settings.get('core', 'rollMode'),
            //style: CONST.CHAT_MESSAGE_STYLES.ROLL,
            rolls: [baseRoll, extraRoll].filter(Boolean)
        });

        return { baseRoll, extraRoll, finalTotal };
    }

    


}
