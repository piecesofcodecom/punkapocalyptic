/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class PunkapocalypticActor extends Actor {
    /** @override */
    prepareData() {
        // Prepare data for the actor. Calling the super version of this executes
        // the following, in order: data reset (to clear active effects),
        // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
        // prepareDerivedData().
        super.prepareData();
    }

    /**
    * Prepare derived data for vehicles.
    */
    async vehiclePrepareDerivedData() {
        const actorData = this;
        actorData.system.defense.current = actorData.system.defense.base + actorData.system.speed.current;
        actorData.system.abilities.hands.value = 0;
        if (actorData.system.speed.current > 0) {
            actorData.system.abilities.muscles.value = 10 + actorData.system.speed.current;
            actorData.system.abilities.feet.value = 10 + actorData.system.speed.current;
        } else {
            actorData.system.abilities.muscles.value = 0;
            actorData.system.abilities.feet.value = 0;
        }
        const driver = actorData.system.occupants.find(i => i.driver);
        if (driver) {
            const actordriver = await fromUuid(driver.uuid);
            if (actordriver) {
                actorData.system.abilities.hands.value = actordriver.system.abilities.hands.value - 5;
            }
        }
    }

    /**
    * Prepare derived data for characters.
    */
    async characterPrepareDerivedData() {
        const actorData = this;
        // Calculate defense value
        const defenseBase = actorData.system.defense.base;
        const armorItems = actorData.items.filter(i => i.type === "armor" && i.system.equipped);

        if (armorItems.length > 0) {
            const armor = armorItems[0]; // Using first equipped armor
            actorData.system.defense.current = armor.system.isBonus
                ? defenseBase + armor.system.defense
                : armor.system.defense;
        } else {
            actorData.system.defense.current = defenseBase;
        }
    }

    /**
    * Prepare derived data for NPCs.
    */
    async npcPrepareDerivedData() {
        const actorData = this;
    }

    /**
     * @override
     * Augment the actor source data with additional dynamic data that isn't 
     * handled by the actor's DataModel. Data calculated in this step should be
     * available both inside and outside of character sheets (such as if an actor
     * is queried and has a roll executed directly from it).
     */
    async prepareDerivedData() {
        const actorData = this;
        switch (actorData.type) {
            case 'vehicle':
                this.vehiclePrepareDerivedData();
                break;
            case 'character':
                this.characterPrepareDerivedData();
                break;
            case 'npc':
                this.npcPrepareDerivedData();
                break;
        }

        for (const key in actorData.system.abilities) {
            // Calculate the modifier using d20 rules.
            actorData.system.abilities[key].mod = Math.floor((actorData.system.abilities[key].value - 10));
            // Handle ability label localization.
            actorData.system.abilities[key].label = game.i18n.localize(CONFIG.PUNKAPOCALYPTIC.abilities[key]) ?? key;
        }
    }

    /**
     * @override
     * Augment the actor's default getRollData() method by appending the data object
     * generated by the its DataModel's getRollData(), or null. This polymorphic 
     * approach is useful when you have actors & items that share a parent Document, 
     * but have slightly different data preparation needs.
     */
    getRollData() {
        return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
    }

    /**
     * Convert the actor document to a plain object that includes derived data.
     * Used when derived data is needed in the plain object representation.
     * @returns {object} Plain object with derived data included
     */
    toPlainObject() {
        // Create base object with spread to include derived properties
        const result = { ...this };

        // Add system data in plain object form
        result.system = this.system.toPlainObject();

        // Add collections as arrays
        result.items = this.items?.size > 0 ? this.items.contents : [];
        result.effects = this.effects?.size > 0 ? this.effects.contents : [];

        return result;
    }

    async applyDamage(damage) {
        const newHealth = this.system.health.value - damage;
        await this.update({ "system.health.value": newHealth });
        //this.system.
    }

    /**
     * Roll an ability check for this actor.
     * @param {string} id - The ability ID to roll
     * @param {number} extraMod - Additional modifier or number of bonus/penalty dice to roll
     * @param {string} content - Optional custom content for the chat message
     * @returns {Object} Object containing the rolls and final total
     */
    async rollAbility(id, extraMod = 0, content = "") {
        const actor = this;
        if (!actor.system.abilities.hasOwnProperty(id)) return null;

        // Get localized ability name and prepare flavor text
        const label = game.i18n.localize(CONFIG.PUNKAPOCALYPTIC.abilities[id]);
        const roll_message = game.i18n.localize("PUNKAPOCALYPTIC.Messages.Rolling", { ability: label });
        const flavor = content || `
            <img src="${CONFIG.PUNKAPOCALYPTIC.abilityImages[id]}" alt="Icon" class="message-icon">
            <p style="font-family: 'Poison Hope', sans-serif; text-shadow: 2px 2px 5px gray;">${roll_message}</p>`;

        // Roll the base ability check
        const baseRoll = await new Roll(`1d20+@abilities.${id}.mod`, actor.getRollData()).evaluate({ async: false });

        // Format modifier for display
        const abilityMod = Number(actor.system.abilities[id].mod);
        const modifierDisplay = abilityMod === 0 ? "" :
            (abilityMod > 0 ? ` + ${abilityMod}` : ` - ${Math.abs(abilityMod)}`);

        // Handle extra dice if extraMod is provided
        let extraRoll = null;
        let highestD6 = 0;
        let highlightDie = "";

        if (extraMod !== 0) {
            // Number of dice to roll is the absolute value of extraMod
            const numDice = Math.abs(extraMod);
            extraRoll = await new Roll(`${numDice}d6`).evaluate({ async: false });

            // Find highest d6 result
            if (extraRoll && extraRoll.dice[0]) {
                highestD6 = Math.max(...extraRoll.dice[0].results.map(r => r.result));

                // For negative modifiers, we'll subtract the highest value
                if (extraMod < 0) {
                    highestD6 = -highestD6;
                    highlightDie = "min"; // Use min class for highest die when it's a penalty
                } else {
                    highlightDie = "max"; // Use max class for highest die when it's a bonus
                }
            }
        }

        // Calculate final total
        const finalTotal = baseRoll.total + highestD6;

        // Build the base dice display HTML
        const baseDiceHTML = `
        <div class="dice">
            <header class="part-header flexrow">
                <span class="part-formula">1d20${modifierDisplay}</span>
                <span class="part-total">${baseRoll.total}</span>
            </header>
            <ol class="dice-rolls">
                <li class="roll die d20 max">${baseRoll.terms[0].results[0].result}</li>
            </ol>
        </div>`;

        // Build extra dice HTML if applicable
        let extraDiceHTML = '';
        if (extraRoll) {
            const extraDiceSign = extraMod < 0 ? "-" : "+";
            extraDiceHTML = `
            <div class="dice">
                <header class="part-header flexrow">
                    <span class="part-formula">${Math.abs(extraMod)}d6 ${extraDiceSign}</span>
                    <span class="part-total">${Math.abs(highestD6)}</span>
                </header>
                <ol class="dice-rolls">
                    ${extraRoll.dice[0].results.map(r =>
                `<li class="roll die d6${r.result === Math.abs(highestD6) ? ` ${highlightDie}` : ''}">${r.result}</li>`
            ).join("")}
                </ol>
            </div>`;
        }

        // Construct the final message content
        const messageContent = `
        <div class="dice-roll" data-action="expandRoll">
            <div class="dice-result">
                <div class="dice-formula">1d20${modifierDisplay}</div>
                <div class="dice-tooltip">
                <div class="wrapper">
                    <section class="tooltip-part">${baseDiceHTML}</section>
                    </div>
                </div>

                ${extraRoll ? `
                <div class="dice-formula">${Math.abs(extraMod)}d6 ${extraMod < 0 ? "(complicações)" : "(Recursos)"}</div>
                <div class="dice-tooltip">
                <div class="wrapper">
                    <section class="tooltip-part">${extraDiceHTML}</section>
                    </div>
                </div>` : ""}

                <h4 class="dice-total">${finalTotal}</h4>
            </div>
        </div>`;

        // Send message to chat
        try {
            await ChatMessage.create({
                speaker: ChatMessage.getSpeaker({ actor: actor }),
                flavor: flavor,
                content: messageContent,
                rollMode: game.settings.get('core', 'rollMode'),
                rolls: [baseRoll, extraRoll].filter(Boolean)
            });
        } catch (error) {
            console.error("Error creating chat message:", error);
        }

        return { baseRoll, extraRoll, finalTotal };
    }
}